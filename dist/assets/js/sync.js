var h=Object.defineProperty;var y=(a,s,t)=>s in a?h(a,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[s]=t;var e=(a,s,t)=>(y(a,typeof s!="symbol"?s+"":s,t),t);import{W as r,o,S as i,c as u,l as f,a as v,i as T,b as l}from"./webdav.js";class A{constructor(){e(this,"callbacks",{})}on(s,t){this.callbacks[s]?this.callbacks[s].push(t):this.callbacks[s]=[t]}emit(s,...t){const c=this.callbacks[s];c&&c.length&&c.forEach(n=>n.apply(this,t))}off(s,t){const c=this.callbacks[s];if(c&&c.length)if(t){const n=c.filter(S=>S!==t);n.length?this.callbacks[s]=n:delete this.callbacks[s]}else delete this.callbacks[s]}}function I(){return chrome.storage.local.get(l.AUTO_SYNC).then(a=>a[l.AUTO_SYNC]===1)}class E extends A{constructor(t){var c;super();e(this,"syncStatus");e(this,"syncTimer",0);e(this,"syncInterval",r);e(this,"startSync",f.exports.throttle(async function(){this.stopSync(),this.syncStatus=i.BEGIN,await this.runDataSyncTick();const t=this.getSyncInterval();this.syncTimer=setInterval(async()=>{await this.runDataSyncTick()},t)},v));this.syncInterval=(c=t==null?void 0:t.syncInterval)!=null?c:r,this.tryStartSync(),this.setupAutoSync()}setupAutoSync(){o(()=>{I().then(t=>{t&&this.tryStartSync()})})}stopSync(){clearInterval(this.syncTimer),this.syncStatus=i.WAIT}async runDataSyncTick(){try{await u()&&this.emit("received"),this.syncStatus=i.SUCCESS}catch(t){console.log(t),this.syncStatus=i.FAIL}}getSyncInterval(){return this.syncInterval||r}tryStartSync(){T()&&this.startSync()}}export{E as S,I as i};
//# sourceMappingURL=sync.js.map
